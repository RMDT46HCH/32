# GPIO 
##  简介：
gpio 一个通用I/O端口有10个寄存器，且都为32位，

![alt text](image-1.png)
### 简介引申：常用寄存器的介绍
#### 端口模式寄存器（`MODER`）
用于配置每个 **IO引脚的工作模式**。

---
![alt text](image-3.png)
1. **位宽结构**：
   - `MODER` 是一个 **32位寄存器**。
   - 每个 GPIO 端口（如 `GPIOA`, `GPIOB` 等）有 16 个引脚（例如 PA0 ~ PA15）。
   - 每个引脚使用 **2位** 来配置其模式，因此总共需要 `16 × 2 = 32位`。


2. **配置方式**：
   - 每个引脚对应的两个位可以设置为以下值：
     | 二进制值 | 模式                  |
     |----------|-----------------------|
     | 00       | 输入模式              |
     | 01       | 输出模式              |
     | 10       | 复用功能模式          |
     | 11       | 模拟模式              |

3. **示例：配置 PA5 为输出模式**
```c
// 先要PA5清除原有配置（因为每个引脚占 2 位，所以第 5 个引脚从第 `5 × 2 = 10` 位开始。0x3 << (5 * 2)：变成 0xC00（二进制 `1100 0000 0000`）。再按位取反，得到0xFFFFF3FF，除了第 10、11 位外其余都为 1。&=后：第十、十一位变成0，其他不变）
GPIOA->MODER &= ~(0x3 << (5 * 2));  // 清除原有配置
// 设置为输出模式（二进制值为01）(第10和11位此时已经是00了，或什么得到的就是什么)
GPIOA->MODER |= (0x1 << (5 * 2));   
```
---


#### 端口输出类型寄存器 (`OTYPER`)
主要决定是推挽还是开漏输出

![alt text](image-4.png)
![alt text](image-5.png)
---
1. **位宽结构**：
   - `OTYPER` 是一个 **32位寄存器**。
   - 每个 GPIO 引脚占用 **1位**（共支持最多 16 个引脚）

2. **作用**：
   - 控制每个引脚的 **输出电路结构类型**。
   - 影响引脚在输出模式下的电气特性和驱动能力。

3. **配置方式**：
   - 每个引脚对应一位（bit）：
     | 值 | 输出类型       
     |----|----------------
     | 0  | 推挽输出（PP） 
     | 1  | 开漏输出（OD） 

4. **示例：将 PA5 配置为开漏输出**
   ```c
   // 设置为开漏输出
   GPIOA->OTYPER |= (1 << 5);
   // 设置为推挽输出
   GPIOA->OTYPER &= ~(1 << 5);
   ```
---




####  输出速度寄存器(OSPEEDR) ：
![alt text](image-6.png)
用于配置每个 GPIO 引脚在输出模式下的 **驱动速度等级（Slew Rate）**

---

1. **位宽结构**
- `OSPEEDR` 是一个 **32位寄存器**。
- 每个 GPIO 引脚占用 **2位** 来设置速度等级。
- 支持最多 16 个引脚（如 PA0 ~ PA15），总共需要 `16 × 2 = 32位`。

2. **作用**
- 控制引脚输出信号的 **上升/下降时间（slew rate）**。
- 高速模式下，IO 反应更快，但可能带来更高的功耗和电磁干扰。
- 低速模式下，功耗更低、更稳定，适合低频外设（如按键、LED、I2C 等）。

3. **配置方式**

| 二进制值 | 速度等级         | 描述                           |
|----------|------------------|--------------------------------|
| 00       | Very Low Speed   | 极低速，适用于低频或远距离通信 |
| 01       | Low Speed        | 低速                            |
| 10       | High Speed       | 高速                            |
| 11       | Very High Speed  | 极高速，适合高速外设（如SPI）  |

4. **示例：将 PA5 设置为中速输出**
```c
// 清除 PA5 的原有速度配置
GPIOA->OSPEEDR &= ~(0x3 << (5 * 2));  
// 设置为中速输出
GPIOA->OSPEEDR |= (0x2 << (5 * 2));
```

---


- **低功耗场景**（如 LED 控制）：选择 `Very Low` 或 `Low`。
- **高速通信**（如 SPI、FSMC）：选择 `High` 或 `Very High`。
- **减少 EMI**：避免不必要的高速配置，尤其是在布线较长或对干扰敏感的设计中。



---

#### 上拉下拉寄存器（ PUPDR ）
![alt text](image-7.png)
![alt text](image-8.png)
---

1. **位宽结构**
- `PUPDR` 是一个 **32位寄存器**。
- 每个 GPIO 引脚占用 **2位** 来设置其上下拉状态。
- 支持最多 16 个引脚（如 PA0 ~ PA15），总共需要 `16 × 2 = 32位`。

2. **作用**
- 控制每个引脚是否启用 **内部上拉电阻** 或 **下拉电阻**。
- 在输入模式下，防止引脚悬空（floating），提高稳定性。
- 在开漏输出模式下，配合外部上拉实现逻辑高电平。

3. **配置方式**
每个引脚对应的两位可设置为以下值（以 STM32F4 系列为例）：

| 二进制值 | 配置类型        | 描述                           |
|----------|------------------|--------------------------------|
| 00       | No Pull-up/Pull-down | 无上下拉（默认状态）         |
| 01       | Pull-up          | 启用内部上拉电阻               |
| 10       | Pull-down        | 启用内部下拉电阻               |
| 11       | Reserved         | 保留，不能使用                 |

---

4. 将 PA5 设置为上拉输入

```c
// 设置为输入模式
GPIOA->MODER &= ~(0x3 << (5 * 2));  // 清除原有配置
GPIOA->MODER |= (0x00 << (5 * 2));  // 输入模式

// 设置为上拉
GPIOA->PUPDR &= ~(0x3 << (5 * 2));  // 清除原有配置
GPIOA->PUPDR |= (0x01 << (5 * 2));  // 上拉
```


---

5. 使用场景建议

| 场景                    | 推荐配置     | 说明                                      |
|-------------------------|--------------|-------------------------------------------|
| 按键检测（低电平有效）   | 上拉         | 按键未按下时为高电平，按下接地变为低电平    |
| 总线通信（如 I2C）       | 上拉         | 开漏输出需外部/内部上拉才能输出高电平       |
| 复位信号输入             | 下拉         | 默认低电平有效，避免干扰导致误复位          |
| 悬空引脚（不影响系统）   | 无上下拉     | 减少功耗                                  |



---

#### 输入数据寄存器（IDR）：
用于读取 GPIO 引脚当前的 **输入电平状态**（高电平或低电平）。
![alt text](image-9.png)

1. **位宽结构**
- `IDR` 是一个 **32位只读寄存器**。
- 每个 GPIO 引脚对应 1 位（bit）。
- 低 16 位（bit 0 ~ bit 15）代表该端口的 16 个引脚（如 PA0 ~ PA15），高 16 位保留。

2. **作用**
- 实时反映每个引脚的 **外部输入电平状态**。
- 常用于检测按键、开关、传感器等外部信号。
- 只读，不能通过写操作改变其值。

3. **配置前提**
要使用 `IDR` 读取某个引脚的状态，需确保：
- 引脚已配置为 **输入模式（MODER[x: x+1] = 00）**
- 上下拉电阻根据需要配置（PUPDR）

4.  示例：读取 PA5 的输入电平

```c
// 1. 设置为输入模式
GPIOA->MODER &= ~(0x3 << (5 * 2));  // 清除原有配置
GPIOA->MODER |= (0x00 << (5 * 2));  // 输入模式

// 2. 设置上拉（可选）
GPIOA->PUPDR &= ~(0x3 << (5 * 2));  // 清除原有配置
GPIOA->PUPDR |= (0x01 << (5 * 2));  // 上拉

// 3. 读取输入状态
if ((GPIOA->IDR & (1 << 5)) != 0) {
    // 高电平
} else {
    // 低电平
}
```

- `(1 << 5)`：构造掩码，仅关注第 5 位。
- `GPIOA->IDR & (1 << 5)`：判断该位是否为 1。
- 若结果不等于 0，则表示该引脚为高电平。

---

5. 典型应用场景

| 场景         | 描述 |
|--------------|------|
| 按键检测     | 将按键一端接地，另一端接 PA0，通过 `GPIOA->IDR & (1 << 0)` 检测按键是否按下。 |
| 外部中断触发前检测 | 在进入中断前先读 IDR 确认当前电平，防止误触发。 |
| 数字信号采集 | 读取来自其他数字设备的高低电平信号，如传感器输出、编码器信号等。 |

---

6. 注意事项

- **只能读取输入引脚的状态**，若引脚被配置为输出模式，读取到的是 **输出寄存器 ODR 的值**，而非实际输入电平。
- 不建议频繁轮询 `IDR`，应结合中断机制提高效率（如 EXTI 中断）。
- 读取前可加入延时或去抖动处理（尤其用于按键检测）。

---
##### 扩展：施密特触发器

- 施密特触发器是一种具有 **迟滞特性** 的比较器电路。
- 在 GPIO 输入路径中使用它，可以提高抗干扰能力，防止由于噪声导致的误判。
- 特点：
  - 有两个阈值电压：一个用于上升沿检测，一个用于下降沿检测。
  - 当输入电压从低向高变化时，必须超过较高阈值才会被认为是高电平；反之亦然。

>  在 STM32 等 MCU 的 GPIO 结构中，施密特触发器是输入路径的一部分，用于将模拟信号转化为干净的数字信号供内部逻辑使用。

---

##### TTL 和 CMOS

| 类型 | 全称 | 工作电压 | 阈值特点 | 应用场景 |逻辑高电平标准|逻辑低电平标准
|------|------|----------|-----------|----------|----------|----------|
| TTL  | Transistor-Transistor Logic | 通常为 5V | 固定阈值（约 1.4V） | 早期数字电路 |>=2v|<=0.8V
| CMOS | Complementary Metal-Oxide-Semiconductor | 可变（如 3.3V、5V） | 阈值与电源电压相关（约为 VDD/2） | 现代低功耗芯片 |>=2.31V|<=0.99v

- MCU 的 GPIO 接口通常兼容 **CMOS 电平标准**。

---


#### Output Data Register（ODR）

![alt text](image-10.png)
1.  **位宽结构**
- `ODR` 是一个 **32位寄存器**，每个 GPIO 端口都有一个。
- 每一位（bit）对应一个引脚（如 PA0 ~ PA15），高 16 位保留不用。

2. **作用**
- 用于设置某个引脚的 **输出电平状态**：
  - 写入 `1`：引脚输出 **高电平**
  - 写入 `0`：引脚输出 **低电平**
---

3. **使用方式**

```c
// 设置 PA5 为高电平
GPIOA->ODR |= (1 << 5);
// 设置 PA5 为低电平
GPIOA->ODR &= ~(1 << 5);
```

---

3. 注意事项

| 项目 | 说明 |
|------|------|
| 需要提前配置引脚为输出模式 | MODER[x: x+1] = 01 |
| 如果引脚被配置为输入模式 | ODR 的值不会影响实际电平，应读取 IDR |
| 不适用于快速切换电平 | 如需频繁翻转电平，建议使用 BSR/BSSR 寄存器 |

---

4. 和 BSR/BSSR 的区别

- `ODR` 是直接写整个寄存器值，修改某一位时需要先读再写，容易引起竞争。
- `BSR` / `BSSR` 支持 **原子操作**，可直接设置或清除某一位而不影响其他位，适合中断服务函数中使用。
- 为什么有了 ODR 还要有 BSRR？

| 对比项 | `ODR` | `BSRR` |
|--------|--------|--------|
| 修改方式 | 直接写整个寄存器，需先读再写 | 原子操作，直接写单个 bit |
| 是否影响其他引脚 | ✅ 会 | ❌ 不会 |
| 是否适用于中断 | ⚠️ 不太安全 | ✅ 推荐使用 |
| 操作效率 | 较低 | 更高 |

---

5.  应用场景

| 场景 | 示例 |
|------|------|
| LED 控制 | 通过 ODR 控制灯亮灭 |
| 数码管显示 | 控制段选和位选信号 |
| 输出固定电平信号 | 如控制使能端、复位端等 |

---


#### `BSRR` 寄存器（Bit Set/Reset Register）



1. **位宽结构**
- 一个 **32位寄存器**。
- 前16位（0~15）：写入 `1` 来 **置高电平（Set）**
- 后16位（16~31）：写入 `1` 来 **置低电平（Reset）**

>  写入 BSRR 时不需要读取当前值，是线程安全的，适合中断中使用。

2. 功能：
- 用于 **设置或清除某个 IO 引脚的输出状态**。
- 支持原子操作，可以在不破坏其他引脚状态的前提下，安全地修改某一位。

3. 示例：控制 PA5 的高低电平

```c
// 设置 PA5 为高电平 (前16位（0~15）：写入 1 来 **置高电平（Set）)

GPIOA->BSRR = (1 << 5);

// 设置 PA5 为低电平 (后16位（16~31）：写入 1 来 置低电平（Reset）)

GPIOA->BSRR = (1 << (5 + 16));
```

4. 特点：

| 特性 | 描述 |
|------|------|
| 安全性 | 支持原子操作，不会影响其他引脚 |
| 用法 | 控制单个引脚的置位或复位 |
| 对应寄存器 | 实际影响 `ODR` 寄存器的值 |
| 推荐场景 | 在中断服务函数中频繁切换引脚状态 |

---

#### `LCKR` 寄存器（Lock Register）

1.  位宽结构：
- 一个 **32位寄存器**。
- 每位对应一个引脚：
- 若某位设为 `1`，则对应的引脚配置被锁定。
- 第 16 位（LCKK）是“锁密钥”位，必须按特定顺序写入才能生效。

2. 功能：
- 用于 **锁定某个引脚的配置**（如模式、上下拉、速度等），防止误改。
- 一旦配置被锁定，在下次系统复位前无法更改。


3. 示例：（以 PA5 为例）：

```c
// 第一步：设置要锁定的引脚（PA5）
GPIOA->LCKR |= (1 << 5);

// 第二步：激活锁机制（先写 1，再写 0 到 LCKK 位）
GPIOA->LCKR |= (1 << 16); // LCKK = 1
GPIOA->LCKR &= ~(1 << 16); // LCKK = 0
GPIOA->LCKR |= (1 << 16); // LCKK = 1

// 读回一次 LCKR 触发硬件锁机制
volatile uint32_t tmp = GPIOA->LCKR;
tmp++; // 防止编译器优化
```


| 操作 | 目的 |
|------|------|
| `GPIOA->LCKR` 被读取 | 向硬件表明“我已经确认了当前的锁配置” |
| `tmp++` | 防止编译器将上面的读操作优化掉 |

#####  为什么要用 `volatile`？
- `volatile` 告诉编译器：“这个变量可能随时被外部改变（比如硬件）”，**不要优化对该变量的访问**。
- 如果不用 `volatile`，编译器可能会认为 `tmp` 是无意义的局部变量，从而直接删除这一行代码。

##### 为什么要 `tmp++` ?

- 编译器有时会对未使用的变量进行优化（即“dead code elimination”）。
- 加上 `tmp++` 是为了让编译器认为这个变量是有用的，**不会把前面的读操作优化掉**。
- 实际上 `tmp++` 并没有实际作用，只是用来“欺骗”编译器保留读操作。



4.  注意事项：
- 一旦锁定，不能解锁，除非复位芯片。
- 多用于关键引脚（如复位、时钟、看门狗信号），防止运行时意外更改。

5. 特点总结：

| 特性 | 描述 |
|------|------|
| 作用 | 锁定引脚配置，防止误改 |
| 可锁定内容 | MODER、OTYPER、OSPEEDR、PUPDR、AFRL/AFRH |
| 是否可逆 | ❌ 不可逆，只能复位解除 |
| 使用建议 | 用于保护关键引脚配置 |

---

6. BSRR vs LCKR 对比表

| 项目 | `BSRR` | `LCKR` |
|------|--------|--------|
| 类型 | 输出控制寄存器 | 配置锁定寄存器 |
| 主要用途 | 设置/清除某个引脚的输出电平 | 锁定引脚配置（模式、上下拉等） |
| 是否影响 ODR | ✅ 是，最终反映在 ODR 上 | ❌ 否，只影响配置寄存器 |
| 是否支持原子操作 | ✅ 是 | ✅ 是（但仅用于锁定） |
| 是否可逆 | ✅ 可随时更改 | ❌ 不可逆，只能复位解除 |
| 应用场景 | 控制 LED、继电器、快速翻转电平 | 保护关键引脚配置，防误操作 |

---

### GPIO主要特性(其实是对上面的一些小总结)
#### 输出状态
| 决定因素 | 寄存器 | 描述 |
|----------|--------|------|
| 工作模式 | `MODER` | 必须配置为输出或复用功能模式 |
| 输出类型 | `OTYPER` | 推挽或开漏 |
| 输出电平 | `ODR` / `BSRR` | 控制高/低电平输出 |
| 输出速度 | `OSPEEDR` | 影响上升/下降沿快慢，控制驱动能力与EMI |
| 外设复用 | `AFRL` / `AFRH` | 若启用复用功能，则输出来自外设而非软件控制 |

##### 输出类型
控制引脚是 **推挽输出（Push-Pull）** 还是 **开漏输出（Open-Drain）**
![alt text](image-13.png)

###### 推挽输出
输出高电平 置1，P-MOS 导通。输出低电平 置0，N-MOS 导通。输出低电平
优势：驱动能力强
驱动LED灯时需要挂载电阻（分压），防止把灯烧掉。
###### 开漏输出
置0，正常输出低电平。
置1，高阻态，需要上拉电阻
###### 

| 配置 | 描述 |
|------|------|
| 推挽输出（PP） | 可主动输出高/低电平，驱动能力强，适合高速场景 |
| 开漏输出（OD） | 只能主动拉低，需外部上拉电阻才能输出高电平，常用于 I2C 等总线通信 |

示例：设置 PA5 为开漏输出
```c
GPIOA->OTYPER |= (1 << 5); // 设置为开漏
```

---

##### 输出数据来源

GPIO 的输出电平最终由以下两个寄存器之一控制：

 1. `ODR` 寄存器（Output Data Register）
- 直接写入该寄存器可以控制输出电平。
- 缺点：修改某一位时需要先读再写，容易影响其他引脚。

```c
GPIOA->ODR |= (1 << 5);  // 设置 PA5 为高电平
GPIOA->ODR &= ~(1 << 5); // 设置 PA5 为低电平
```

2. `BSRR` / `BSSR` 寄存器（Bit Set/Reset Register）
- 更推荐使用，支持原子操作。
- 前16位用于置高电平，后16位用于置低电平。
- 不会影响其他引脚状态。

```c
GPIOA->BSRR = (1 << 5);       // 设置 PA5 为高电平
GPIOA->BSRR = (1 << (5 + 16)); // 设置 PA5 为低电平
```

---

##### 输出速度（`OSPEEDR` 寄存器）

控制引脚的 **上升/下降时间（Slew Rate）**，影响输出响应速度和电磁干扰。

| 速度等级 | 应用场景 |
|----------|----------|
| 极低速 / 低速 | LED、按键等低频设备，功耗低、稳定性好 |
| 高速 / 极高速 | SPI、FSMC 等高速外设 |

示例：设置 PA5 输出速度为中速
```c
GPIOA->OSPEEDR &= ~(0x3 << (5 * 2)); // 清除旧值
GPIOA->OSPEEDR |= (0x2 << (5 * 2));  // 设置为高速（binary: 10）
```

---

##### 复用功能（AFRL / AFRH）

如果 GPIO 被配置为 **复用模式（Alternate Function）**，则输出信号来自外设模块（如 SPI、I2C、PWM 等），而不是 ODR 或 BSRR。

输出缓冲设置为推挽/开漏
施密特触发激活
PUPDR：设置上拉/下拉，阻值为30k欧-50k欧
输入采集周期：每个AHB时钟周期采集一次
通过输入数据寄存器读取输出值
不能控制输出ODR寄存器，只能通过复用外设控制

---
##### 上下拉
1. 什么是上下拉电阻？

在数字电路中，一个引脚如果没有明确的输入信号，会处于“浮空”状态（floating），容易受到干扰导致电平不稳定。为了解决这个问题，可以使用：

- **上拉电阻（Pull-up）**：将引脚默认拉高到 VDD（如 3.3V）
- **下拉电阻（Pull-down）**：将引脚默认拉低到 GND
-  阻值在30k欧-50k欧
---

功能：
- 控制每个 GPIO 引脚是否启用内部 **上拉或下拉电阻**
- 在 **输入模式** 下防止浮空
- 在 **开漏输出** 模式下辅助实现高电平


常见应用场景：

| 场景             | 推荐配置     | 说明                                       |
|------------------|--------------|--------------------------------------------|
| 按键检测（低电平触发） | 上拉         | 按键未按下时默认高电平，按下接地变为低电平 |
| I2C 通信         | 上拉         | 开漏输出需要外部/内部上拉才能形成高电平      |
| 复位信号输入      | 下拉         | 默认低电平无效，高电平触发复位              |
| 悬空引脚         | 无上下拉     | 减少功耗                                   |


#####  典型应用示例：点亮 LED（PC13）
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); // 置低电平（点亮 LED）
![alt text](image-11.png)
```c
// 1. 设置为输出模式
GPIOC->MODER &= ~(0x3 << (13 * 2));
GPIOC->MODER |= (0x1 << (13 * 2)); // 输出模式

// 2. 设置为推挽输出
GPIOC->OTYPER &= ~(1 << 5); // 推挽（默认）

// 3. 设置输出速度为中速
GPIOC->OSPEEDR &= ~(0x3 << (13 * 2));
GPIOC->OSPEEDR |= (0x2 << (13 * 2));

// 4. 设置低电平
GPIOC->BSRR = (1 << (13 + 16)); // PC13 输出低电平
```

---
#### 输入状态
**模拟输入** 与 **浮空输入**

GPIO（通用输入输出）引脚在配置为 **输入模式** 时，可以进一步细分为：
- **模拟输入（Analog Input）**
- **浮空输入（Floating Input）**
- **上拉输入（Pull-up Input）**
- **下拉输入（Pull-down Input）**

1. 模拟输入（Analog Input）

输出缓冲关闭
施密特触发关闭
上下拉禁止（影响电压采集）
![alt text](image-14.png)
开启开关时，可通过PA0_C(直接读取速度最快，做通用gpio受基准电压影响)/PA0读取ADC
![alt text](image-15.png)

1. 基本概念
- 当 GPIO 引脚被配置为 **模拟输入模式** 时，它不再作为数字信号使用，而是用于连接 **ADC（模数转换器）模块**。
- 此时引脚直接将外部的模拟电压传送到 ADC 输入通道，用于采集电压值（如传感器数据）。

2. 配置步骤
```c
// 设置 PA0 为模拟输入模式
GPIOA->MODER |= (0x3 << (0 * 2)); // MODER[1:0] = 11 -> 模拟模式
GPIOA->PUPDR &= ~(0x3 << (0 * 2)); // 禁用上下拉（不影响模拟输入）
```

3. 特点
| 特性 | 描述 |
|------|------|
| 不启用上下拉电阻 | 引脚处于高阻态，不主动拉高或拉低 |
| 连接 ADC 模块 | 引脚电压直接送入 ADC 转换器进行采样 |
| 无施密特触发器 | 数字输入路径关闭，避免干扰模拟信号 |
| 适用于传感器采集 | 如温度、湿度、光敏等模拟信号 |

4. 应用场景
- 使用 ADC 测量电池电压
- DAC、比较器、运算
- 读取电位器、热敏电阻、光敏电阻等模拟器件的值

---

2. 浮空输入（Floating Input）
![alt text](image-12.png) 
输出缓冲禁止
施密特触发激活
![alt text](1746637204964.png)
比较器      :>2.5V认为高电平 
施密特触发器：>3V 认为高电平（起到一个滤波作用）
输入采集周期：每个AHB时钟周期采集一次
通过输入数据寄存器读取输出值

基本概念
- **浮空输入** 是数字输入的一种模式，表示引脚没有内部上拉或下拉电阻，处于“悬空”状态。
- 引脚的电平由外部电路决定，若未连接任何驱动源，电平可能是不确定的（高/低都可能），容易受噪声干扰。

配置步骤
```c
// 设置 PA0 为浮空输入模式
GPIOA->MODER &= ~(0x3 << (0 * 2)); // 清除原有配置
GPIOA->MODER |= (0x0 << (0 * 2));  // 输入模式
GPIOA->PUPDR &= ~(0x3 << (0 * 2)); // 禁用上下拉
```

特点
| 特性 | 描述 |
|------|------|
| 没有内部上拉/下拉 | 引脚电平完全由外部决定 |
| 可能出现不确定电平 | 若未连接有效驱动源，易受干扰 |
| 功耗最低 | 因为没有电流流动 |
| 需配合外部电路使用 | 否则不适合稳定检测 |

应用场景
- 外部驱动明确的场合（如另一个 MCU 或 IC 控制的信号线）
- 不需要内部上下拉的特定接口协议（如某些串行总线）

---

模拟输入 vs 浮空输入 对比表

| 项目 | 模拟输入（Analog Input） | 浮空输入（Floating Input） |
|------|--------------------------|----------------------------|
| 引脚用途 | 连接 ADC，采集模拟电压 | 作为数字输入，但无上下拉 |
| 是否启用上下拉 | ❌ 禁用 | ❌ 禁用 |
| 是否启用施密特触发器 | ❌ 不启用 | ✅ 启用（用于数字输入） |
| 输入路径 | 直接送入 ADC | 数字路径，通过 IDR 读取 |
| 适用对象 | 模拟传感器、电压检测 | 外部驱动明确的信号线 |
| 抗干扰能力 | 强（因关闭数字路径） | 弱（易受噪声影响） |
| 典型应用 | ADC 采集 | 外部中断、同步通信 |

---
对比表：三种输入模式的区别

| 项目 | 浮空输入 | 上拉输入 | 下拉输入 |
|------|----------|-----------|-----------|
| 是否启用上拉 | ❌ 否 | ✅ 是 | ❌ 否 |
| 是否启用下拉 | ❌ 否 | ❌ 否 | ✅ 是 |
| 默认电平 | 不确定 | 高电平 | 低电平 |
| 抗干扰能力 | 弱 | 强 | 强 |
| 功耗 | 最低 | 较低 | 较低 |
| 典型应用 | 外部驱动明确的信号线 | 按键（低电平触发）、I²C | 按键（高电平触发）、复位信号检测 |

---

| 场景 | 推荐输入模式 |
|------|---------------|
| 按键检测（低电平触发） | 上拉输入 |
| 按键检测（高电平触发） | 下拉输入 |
| I²C 通信 | 上拉输入（配合开漏输出） |
| 复位信号输入 | 下拉输入 |
| 外部中断输入 | 根据触发方式选择上/下拉 |
| 未使用的引脚 | 无上下拉（防止不必要的电流） |


注意事项

| 项目 | 建议 |
|------|------|
| 模拟输入不要连接到强驱动电路 | 避免损坏 ADC |
| 浮空输入尽量避免单独使用 | 推荐搭配外部上下拉电阻 |
| 使用前确认引脚支持模拟功能 | 并非所有引脚都能配置为模拟输入 |
| 模拟输入不能用于 EXTI 中断 | 必须是数字输入才能触发中断 |

---

示例：ADC 采集 PA0 模拟电压

```c
// 配置 PA0 为模拟输入
GPIOA->MODER |= (0x3 << (0 * 2));
GPIOA->PUPDR &= ~(0x3 << (0 * 2));

// 启动 ADC 软件校准和自检
ADC1->CR |= ADC_CR_ADEN; // 启动 ADC
while (!(ADC1->ISR & ADC_ISR_ADRDY)); // 等待就绪

ADC1->CHSELR = (1 << 0); // 选择通道 0
ADC1->CR |= ADC_CR_ADSTART; // 开始转换

while (!(ADC1->ISR & ADC_ISR_EOC)); // 等待转换完成
uint16_t adc_value = ADC1->DR; // 获取结果
```

---

总结图解（GPIO 输入模式选择流程）

```
是否需要 ADC 采集？
   ┌───────────────┬────────────────┐
   │       是        │       否        │
   ▼               ▼
模拟输入           数字输入
                   ┌───────────────┐
                   │ 是否启用上下拉？│
                   ├───────┬───────┤
                   │  否   │  是   │
                   ▼       ▼       ▼
                 浮空输入 上拉输入 下拉输入
```

---
#### 快速io翻转
在挂载总线上每两个时钟周期翻转一次。如： 若挂载在ahb4总线上，其速度为240mhz，那么相当于io翻转速度为120mhz。

#### 锁机制
##### GPIO 锁机制详解（Lock Mechanism）

在 STM32 系列 MCU 中，GPIO 引脚的配置可以通过 **LCKR 寄存器（GPIOx_LCKR）** 来锁定，防止程序运行过程中被意外修改。这个机制称为 **GPIO Lock Mechanism（锁机制）**。

---

1. GPIO 锁机制的作用

| 功能 | 描述 |
|------|------|
| 防止误操作 | 一旦某个引脚被锁定，它的模式、上下拉、输出类型等都不能再被修改 |
| 提高系统稳定性 | 特别适用于关键信号线，如复位、时钟、看门狗等 |
| 增强安全性 | 在多任务或中断中使用时，避免多个模块同时修改同一个引脚 |

---

2. 相关寄存器：`LCKR`

- **寄存器名称**：`GPIOx_LCKR`
- **作用**：用于锁定某个引脚的配置
- **第16位（LCKK）** 是“密钥位”，必须按照特定顺序写入才能生效

---

3. 如何启用 GPIO 锁机制（以 PA5 为例）

```c
// 第一步：设置要锁定的引脚（PA5）
GPIOA->LCKR |= (1 << 5); // 设置 LCKR[5] = 1 表示要锁定 PA5

// 第二步：激活锁机制（按顺序写入 LCKK）
GPIOA->LCKR |= (1 << 16);  // 写入 LCKK = 1
GPIOA->LCKR &= ~(1 << 16); // 再写入 LCKK = 0
GPIOA->LCKR |= (1 << 16);  // 最后写入 LCKK = 1

// 第三步：读回一次 LCKR 触发硬件锁机制
volatile uint32_t tmp = GPIOA->LCKR;
tmp++; // 防止编译器优化掉上面的读取操作
```

> ⚠️ 如果不执行完整的写入流程（包括最后的读操作），锁机制不会生效！

---

4. 锁机制的原理说明

STM32 的 GPIO 锁机制通过一个“伪写入”过程来确认用户是**有意图地锁定引脚配置**，防止误触发。

- 操作流程解析：

   1. 写入 `LCKR` 中对应引脚的位为 `1`。
   2. 先写 `LCKK = 1`，再写 `LCKK = 0`，最后再写 `LCKK = 1`。
   3. 读取一次 `LCKR` 寄存器（即使没有使用返回值）。
   4. 硬件检测到这一系列操作后，将该引脚的配置“冻结”。

---

5. 锁机制的关键点

| 项目 | 说明 |
|------|------|
| 是否可逆 | ❌ 不可逆，只能在芯片复位后解锁 |
| 能锁定的内容 | `MODER`, `OTYPER`, `OSPEEDR`, `PUPDR`, `AFRL/AFRH` |
| 使用场景 | 关键控制引脚（如电源控制、安全信号、看门狗） |
| 推荐用途 | 多任务环境下保护 GPIO 配置不被覆盖 |

---

6. 锁机制与 BSRR 对比表

| 项目 | `BSRR` | `LCKR` |
|------|--------|----------|
| 类型 | 输出控制寄存器 | 配置锁定寄存器 |
| 主要用途 | 设置/清除某个引脚的输出电平 | 锁定引脚配置（模式、上下拉等） |
| 是否影响 ODR | ✅ 是，最终反映在 ODR 上 | ❌ 否，只影响配置寄存器 |
| 是否支持原子操作 | ✅ 支持 | ✅ 支持（但仅用于锁定） |
| 是否可逆 | ✅ 可随时更改 | ❌ 不可逆，只能复位解除 |
| 应用场景 | 控制 LED、继电器、快速翻转电平 | 保护关键引脚配置，防误操作 |

---

7. 常见应用场景

| 场景 | 说明 |
|------|------|
| 安全信号控制 | 如看门狗使能引脚、系统复位引脚，防止被错误改写 |
| 多任务访问保护 | 避免多个任务同时修改同一引脚 |
| 固化外设配置 | 如 SPI、I²C、CAN 的引脚，在初始化完成后锁定配置 |

---

8. 注意事项

| 注意项 | 说明 |
|--------|------|
| 一旦锁定无法撤销 | 必须复位芯片才能恢复修改权限 |
| 锁定前确保配置正确 | 锁定后不能再调整引脚状态 |
| 编译器优化问题 | 使用 `volatile` 防止编译器优化掉无意义的读写操作 |
| 不能锁定所有引脚 | 某些引脚可能不支持锁定功能（参考数据手册） |

---

### 通用IO
#### debug引脚
![alt text](28e0426e6785635f7a90a50ee4ec0c6.jpg)
![alt text](1746631121836.png)
AF0上电默认复用

---

1. `PA15`：`JTDI`（JTAG Test Data In）  
- **功能描述**：
  - JTDI 是 JTAG 接口的一部分，用于向芯片输入测试/调试数据。
  - 在 JTAG 模式下，该引脚接收来自调试器的数据。
- **默认状态**：上拉（Pull-up）
- **用途**：
  - 调试、烧录程序
  - 若不使用 JTAG，可将其释放为普通 IO（需禁用 JTAG）
- **代码示例**（释放 PA15 为普通输出）：
  ```c
  __HAL_AFIO_REMAP_SWJ_NOJTAG(); // 禁用 JTAG，保留 SWD

  GPIO_InitTypeDef GPIO_InitStruct = {0};
  GPIO_InitStruct.Pin = GPIO_PIN_15;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; // 推挽输出
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
  ```
---

2. `PA14`：`JTCK/SWCLK`（JTAG Clock / Serial Wire Clock）  
- **功能描述**：
  - 该引脚在 JTAG 模式下作为 **时钟信号输入（JTCK）**
  - 在 SWD（Serial Wire Debug）模式下作为 **SWCLK（时钟线）**
- **默认状态**：下拉（Pull-down）
- **用途**：
  - 提供调试接口的同步时钟
  - 常用于调试和单线调试（SWD）
- **注意**：
  - 若使用 SWD，此引脚不可用作普通 IO。
---
3. `PA13`：`JTMS/SWDIO`（JTAG Mode Select / Serial Wire Data I/O）  
- **功能描述**：
  - JTAG 模式下为 JTMS，控制 JTAG 状态机转换
  - SWD 模式下为 SWDIO，双向数据线
- **默认状态**：上拉（Pull-up）
- **用途**：
  - JTAG/SWD 接口的数据/控制信号
  - 与 SWCLK 配合使用进行调试通信
- **注意**：
  - 通常与 PA14 配合使用于 SWD 接口，是调试核心引脚之一。

---
4. `PB4`：`NJTRST`（Not JTAG Reset，低电平有效）  
- **功能描述**：
  - JTAG 复位信号输入，低电平复位 JTAG 控制器。
  - 可选功能，非必需引脚。
- **默认状态**：上拉（Pull-up）
- **用途**：
  - 调试过程中强制复位 JTAG 接口
  - 若不使用 JTAG，也可作为普通 IO 使用（需关闭 JTAG）

---

5. `PB3`：`JTDO`（JTAG Test Data Out）  
- **功能描述**：
  - JTAG 数据输出引脚，用于从芯片向外输出调试数据。
- **默认状态**：浮空输入（Floating Input）
- **用途**：
  - JTAG 调试时输出数据
  - 若不使用 JTAG，可配置为普通 IO 或其他外设功能
- **注意**：
  - 浮空输入状态下易受干扰，建议根据用途配置合适的上下拉电阻。

---

6. 总结表：五引脚功能一览

| 引脚 | 默认功能 | 功能说明 | 默认上下拉 | 是否可用作普通 IO |
|------|-----------|------------|--------------|------------------|
| `PA15` | `JTDI` | JTAG 数据输入 | 上拉 | ✅ 可释放使用 |
| `PA14` | `JTCK/SWCLK` | JTAG 时钟 / SWD 时钟 | 下拉 | ❌ 不推荐释放（SWD 关键引脚） |
| `PA13` | `JTMS/SWDIO` | JTAG 模式选择 / SWD 数据线 | 上拉 | ❌ 不推荐释放（SWD 关键引脚） |
| `PB4`  | `NJTRST` | JTAG 复位信号（低电平有效） | 上拉 | ✅ 可释放使用 |
| `PB3`  | `JTDO` | JTAG 数据输出 | 浮空输入 | ✅ 可释放使用 |



---
#### IO 引脚的复用和映射（Alternate Function and Remapping）

GPIO 引脚除了可以作为通用输入/输出使用外，还可以配置为 **复用功能（Alternate Function, AF）**，用于连接内部外设模块（如 USART、SPI、I2C 等）。STM32 提供了多个复用功能选项，并支持部分引脚的 **重映射（Remap）**，以提高硬件灵活性。

---

##### 复用功能（AF）

- 每个 GPIO 引脚可通过 `MODER` 寄存器配置为 **复用功能模式（MODER = 10）**
- 具体功能由 `AFRL` 和 `AFRH` 寄存器决定（每个引脚占 4 位）
- STM32 支持最多 **AF0 ~ AF15** 的复用功能

###### 示例：配置 PA9 和 PA10 为 USART1_TX 和 USART1_RX

```c
// 设置 PA9 和 PA10 为复用功能模式
GPIOA->MODER &= ~((0x3 << (9 * 2)) | (0x3 << (10 * 2)));
GPIOA->MODER |=  ((0x2 << (9 * 2)) | (0x2 << (10 * 2))); // AF mode
// 设置复用功能为 AF7（USART1）
GPIOA->AFR[0] &= ~((0xF << (9 * 4)) | (0xF << (10 * 4)));
GPIOA->AFR[0] |=  ((0x7 << (9 * 4)) | (0x7 << (10 * 4)));
```

---

###### AF15 的作用

`AF15` 是一个特殊的复用功能编号，通常用于以下用途：

| 功能 | 描述 |
|------|------|
| `FPU` 事件输出 | 在某些型号中，硬件浮点单元（FPU）可以通过 GPIO 引脚输出异常或中断信号 |
| 调试接口映射 | 可用于调试接口（如 SWO）输出跟踪信息 |
| 特定芯片功能 | 如 `HRTIM`、`LCD` 控制器等高性能外设 |

>  **注意**：`AF15` 的具体用途取决于芯片型号和封装，需参考数据手册确认可用性。

---

#### IO 补偿（IO Compensation）

IO 补偿是一种通过调节 **压摆率（Slew Rate）** 来优化输出信号质量的技术，常用于高速通信接口。

##### 原理与作用：

- **降低噪声**：控制上升/下降沿的陡峭程度，减少电磁干扰（EMI）
- **提升稳定性**：防止因信号过冲或振铃导致的误操作
- **性能平衡**：在速度与功耗之间取得折中

##### 配置方式：

- 通过 `SYSCFG_CMPCR` 寄存器启用补偿
- 需配合 `OSPEEDR` 设置合适的驱动速度

##### 示例（启用 IO 补偿）：

```c
// 启用 SYSCFG 时钟
RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;

// 启动补偿模式
SYSCFG->CMPCR |= SYSCFG_CMPCR_CMP_PD;
while (!(SYSCFG->CMPCR & SYSCFG_CMPCR_READY)); // 等待就绪
```

---

#### 把晶振引脚作为通用 GPIO

STM32 的外部晶振引脚（如 `OSC_IN` 和 `OSC_OUT`）默认用于连接系统时钟源。但在某些应用场景下，也可以将其释放为普通 GPIO 使用。

##### 条件：

- 系统必须使用 **内部时钟源（HSI 或 MSI）**
- 必须关闭外部晶振电路（设置 `RCC_CR` 中的 `HSEON` 为 0）

##### 示例（将 OSC_IN 和 OSC_OUT 作为 GPIO 使用）：

```c
// 关闭 HSE
RCC->CR &= ~RCC_CR_HSEON;

// 设置 OSC_IN（PH0）和 OSC_OUT（PH1）为输出模式
GPIOH->MODER |= (GPIO_MODER_MODE0_0 | GPIO_MODER_MODE1_0); // 输出模式
GPIOH->OTYPER &= ~(GPIO_OTYPER_OT0 | GPIO_OTYPER_OT1);    // 推挽输出
GPIOH->OSPEEDR |= (GPIO_OSPEEDER_OSPEED0 | GPIO_OSPEEDER_OSPEED1); // 高速
```

---

### 备份域（Backup Domain）

备份域是 MCU 中一块特殊区域，在 **系统进入低功耗模式（如 Stop 或 Standby）后仍能保持状态**。该区域通常用于 RTC、唤醒引脚等功能。

#### 特性：

- **电源独立**：通常由 VBAT 引脚供电（可接电池）
- **寄存器保留**：备份域中的寄存器在系统掉电后不会丢失
- **GPIO 特性**：
  - 在 H7 系列中，默认为 **模拟输入（Analog Input）**（低功耗）
  - 在 F1/F4 系列中，默认为 **浮空输入（Floating Input）**

#### 配置方法：

```c
// 使能备份域访问
PWR->CR1 |= PWR_CR1_DBP;

// 配置 PB2（RTC_WAKEUP）为上拉输入
GPIOB->MODER &= ~GPIO_MODER_MODE2;
GPIOB->PUPDR |= GPIO_PUPDR_PUPD2_0; // 上拉
```

---

## 电气特性与参数

### 电流特性

| 类型 | 定义 | 最大值 |
|------|------|--------|
| **拉电流（Source Current）** | 引脚向外输出电流 | 单个引脚 ≤ 20mA，总和 ≤ 140mA |
| **灌电流（Sink Current）** | 引脚接收外部电流 | 单个引脚 ≤ 20mA，总和 ≤ 140mA |
| **注入电流（Injected Current）** | 超出 VDD 或低于 VSS 的电流 | ±25mA |

> ⚠️ 不建议长时间工作在极限电流状态下，否则可能损坏芯片。

---

### IO 特性（High/Low Level）

| 类型 | 输入高电平（VIH） | 输入低电平（VIL） | 输出高电平（VOH） | 输出低电平（VOL） |
|------|-------------------|-------------------|-------------------|-------------------|
| **FT（5V tolerant）** | > 2.0V | < 0.8V | > VDD - 0.3V | < 0.3V |
| **TT（3.3V I/O）**   | > 2.0V | < 0.8V | > VDD - 0.3V | < 0.3V |

---

### 引脚类型标识符说明

| 标识符 | 含义 |
|--------|------|
| `FT` | 5V 耐压引脚，可安全连接 5V 设备 |
| `TT` | 仅支持 3.3V 逻辑电平 |
| `_f` | 支持 I²C FM+ 模式（Fast-mode Plus） |
| `_a` | 模拟功能引脚（可用于 ADC/DAC） |
| `_u` | USB 相关引脚（如 D+/D-） |
| `_h` | 高速低电压 IO，适用于高速信号传输 |

---

### 应用示例

#### I2C 3.3V 供电 + 外部上拉到 5V

- 使用 FT 类型引脚（如 PB6/PB7）
- 外部加上拉电阻至 5V（如 4.7kΩ）
- 可与 5V I2C 设备通信

```c
// 配置 PB6 和 PB7 为开漏输出
GPIOB->MODER |= (GPIO_MODER_MODE6_1 | GPIO_MODER_MODE7_1); // Output mode
GPIOB->OTYPER |= (GPIO_OTYPER_OT6 | GPIO_OTYPER_OT7);      // Open-drain
GPIOB->OSPEEDR |= (GPIO_OSPEEDER_OSPEED6 | GPIO_OSPEEDER_OSPEED7); // High speed
```

---

#### 3.3V 串口直接连接 5V 外设

- 若使用 FT 类型引脚（如 PA9/PA10），可直接连接 5V 设备
- 若非 FT 类型，则需使用电平转换器或限流电阻

```c
// 配置 PA9/PA10 为复用推挽输出
GPIOA->MODER |= (GPIO_MODER_MODE9_1 | GPIO_MODER_MODE10_1);
GPIOA->OTYPER &= ~(GPIO_OTYPER_OT9 | GPIO_OTYPER_OT10);
GPIOA->AFR[1] |= ((7 << 4) | (7 << 8)); // AF7 for USART1
```

---

#### 总结图解：GPIO 多种功能对比表

| 功能 | 描述 | 是否可复用 | 是否支持锁机制 | 典型应用 |
|------|------|-------------|----------------|----------|
| 通用 IO | 输入/输出控制 | ✅ | ✅ | LED 控制、按键检测 |
| 复用功能 | 连接外设模块 | ✅ | ✅ | USART、SPI、I2C |
| 模拟输入 | ADC/DAC 接口 | ❌ | ❌ | 传感器采集 |
| 调试引脚 | JTAG/SWD 接口 | ✅（可释放） | ✅ | 调试、烧录 |
| IO 补偿 | 降低噪声 | ✅ | ❌ | 高速通信 |
| 晶振引脚 | 系统时钟输入 | ✅（需关闭 HSE） | ❌ | 自定义 GPIO |
| 备份域引脚 | 低功耗模式使用 | ✅ | ✅ | RTC、唤醒中断 |

> 📌 推荐做法：优先使用 FT 类型引脚与 5V 设备交互，避免损坏 IO；使用 `BSRR` 和 `LCKR` 实现高效、安全的 GPIO 控制。


## 变量程序在内存中的分布情况
###  RAM 和 FLASH 是什么？

| 名称 | 类型 | 特点 | 用途 |
|------|------|------|------|
| **RAM**（SRAM） | 易失性内存 | 可读可写，速度快，断电后数据丢失 | 存放需要频繁修改的数据，如局部变量、全局变量等 |
| **FLASH** | 非易失性存储器 | 写入慢，读取较快，断电不丢失 | 存放程序代码、只读数据、初始化的全局变量等 |

> 📌 在 STM32 中，**Flash 用于存储编译后的机器码和常量数据**，而 **RAM 用于运行时的数据操作**。

---

## HAL库中关于GPIO函数的实现
### 初始化
`void HAL_GPIO_Init(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)`
各种I/O配置，外部中断
### 复位
`void HAL_GPIO_DeInit(GPIO_TypeDef *GPIOx, GPIO_InitTypeDef *GPIO_Init)`
不上下拉、模拟状态
### 读取
`GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`
用到IDR
### 写入
`void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)`
用到BSRR
### 翻转电平 （GPIOx->BSRR 原子操作）
`void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`
### 锁定
`HAL_StatusTypeDef HAL_GPIO_LockPin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)`


###  常见变量类型及其存储区域

| 变量类型 | 存储区域 | 描述 |
|----------|-----------|--------|
| `const` 常量 | `.rodata` 段（Flash） | 不会改变的数据，如字符串、查找表 |
| 全局变量 / 静态变量（已初始化） | `.data` 段（RAM） | 程序启动时从 Flash 拷贝到 RAM |
| 全局变量 / 静态变量（未初始化） | `.bss` 段（RAM） | 启动时清零，占用 RAM |
| 局部变量 | 栈区（Stack） | 函数调用时分配，函数返回后释放 |
| `malloc` 分配的变量 | 堆区（Heap） | 动态申请，需手动管理生命周期 |
| 寄存器变量 | CPU 寄存器 | 极快访问，但数量有限，由编译器自动优化使用 |

---

###  为什么全局变量要放在 Flash 上？—— 初始化数据是怎么拷贝到 RAM 的？
#### 实际流程如下：

1. **编译链接阶段：**
   - 编译器将所有全局变量、静态变量分为：
     - `.data`：已初始化的全局变量
     - `.bss`：未初始化的全局变量
   - 这些数据都会被放到 Flash 中，作为“初始值”。

2. **MCU 启动时：**
   - 启动文件（通常是 `startup_stm32fxxx.s`）会在 `main()` 被调用前执行以下操作：
     - 将 `.data` 段从 Flash 复制到 RAM。
     - 将 `.bss` 段清零（因为未初始化）。
   - 这样，**全局变量就可以在 RAM 中被正常读写了**。

####  示例说明：

```c
int global_var = 10;    // .data 段，在 Flash 中保存初始值，运行时复制到 RAM
int uninit_var;          // .bss 段，在 RAM 中清零
const int const_val = 5; // .rodata 段，直接存在 Flash，不可写
```

>  如果你尝试在程序中修改 `const_val`，可能会导致 HardFault 或者无法生效，因为它被映射为只读段。

---


### STM32 中常见内存段划分（链接脚本视角）

STM32 使用链接脚本（`.ld` 文件）来划分内存布局，典型的划分如下：

| 段名 | 地址范围 | 内容 |
|-------|------------|--------|
| `.text` | Flash 区间（如 `0x0800_0000`） | 程序指令、函数体 |
| `.rodata` | Flash 区间 | `const` 常量 |
| `.data` | RAM 区间（如 `0x2000_0000`） | 已初始化的全局/静态变量 |
| `.bss` | RAM 区间 | 未初始化的全局/静态变量 |
| `.heap` | RAM 区间 | `malloc` 分配的空间 |
| `.stack` | RAM 区间 | 函数调用时的临时变量、返回地址等 |

---

### STM32 的内存映射与寻址能力


- **32位地址总线** → 最大支持 **4GB 地址空间（0x00000000 ~ 0xFFFFFFFF）**
- **C语言指针大小为 4 字节（32bit）**
- **外设寄存器也映射到该地址空间**（如 GPIOA 位于 `0x40020000`）

###  常见内存映射片段（以 STM32F4 系列为例）：

| 地址区间 | 对应内容 |
|----------|--------------|
| `0x08000000 ~ 0x080FFFFF` | Flash（程序和 const 数据） |
| `0x20000000 ~ 0x2001FFFF` | SRAM（.data/.bss/堆/栈） |
| `0x40000000 ~ 0x400FFFFF` | 外设寄存器（GPIO、USART、ADC 等） |

> 🧠 这就是 C 语言可以直接通过指针访问硬件寄存器的原因：**内存统一编址 + MMU 映射机制**

---

### 变量是如何分布的？

你提到的图解可以简化为以下结构：

```
+-------------------+
|      .text        | --> Flash，存放程序指令
+-------------------+
|     .rodata       | --> Flash，存放 const 常量
+-------------------+
|      .data        | --> RAM，存放已初始化的全局变量
+-------------------+
|      .bss         | --> RAM，存放未初始化的全局变量
+-------------------+
|     Heap（堆）     | --> RAM，动态分配空间（malloc/free）
+-------------------+
|     Stack（栈）     | --> RAM，函数调用时自动分配局部变量
+-------------------+
```

---

### ❓ 为什么不能把频繁变化的全局变量放在 Flash？
- Flash 支持读取和少量写入，但频繁写入会导致寿命损耗（擦写次数有限）。
- Flash 访问速度远低于 RAM，不适合频繁读写。

### ❓ const 为什么要放在 Flash？
- `const` 数据在整个程序运行期间不会变，适合固化在 Flash。
- 节省 RAM 空间，提高效率。

### ❓ 局部变量为什么不能跨函数访问？
- 局部变量存储在 **栈区**，函数调用结束后栈空间会被回收。
- 若想保留其值，必须显式返回或将变量提升为全局变量。

### ❓ 堆区（Heap）什么时候用？
- 当你需要 **动态分配内存**（例如链表、缓冲区、图像处理）时。
- 注意：嵌入式中堆区大小有限，需手动配置（通常在链接脚本或 IDE 中设置）。

---

### 变量存储的本质逻辑

| 存储位置 | 数据种类 | 是否可写 | 是否持久化 |
|----------|----------|-----------|-------------|
| **Flash** | 程序、`const`、初始化数据备份 | ❌（只能读） | ✅ |
| **RAM** | `.data`、`.bss`、堆、栈 | ✅ | ❌（掉电即失） |

> ✅ **全局变量虽然定义在代码中，但它真正的“家”在 RAM**，Flash 只是它的“备份”。


### 扩展知识：

| 关键字 | 存储位置 | 特点 |
|--------|------------|--------|
| `static` | RAM（全局）或 Stack（局部） | 限制作用域，延长生命周期 |
| `volatile` | RAM | 告诉编译器：“这个变量可能随时变化”，防止优化 |
| `register` | CPU 寄存器（建议） | 提高访问速度，适用于高频使用的变量 |

---
### 变量的 **生命周期（Lifetime）**

| 变量类型 | 生命周期 | 描述 |
|----------|-----------|--------|
| 全局变量 | 整个程序运行期间 | 程序开始时创建，结束时销毁 |
| 静态变量（static） | 整个程序运行期间 | 类似全局变量，但作用域受限 |
| 局部变量 | 所在函数调用期间 | 函数进入时分配栈空间，退出时释放 |
| `malloc` 分配的变量 | 手动控制 | 使用 `free()` 显式释放，否则一直存在 |

---
 
### 变量的 **作用域（Scope）**

| 变量类型 | 作用域 | 描述 |
|----------|-----------|--------|
| 全局变量 | 整个项目 | 所有函数都可以访问 |
| 文件级静态变量（`static`） | 当前源文件 | 只能在定义它的 `.c` 文件中访问 |
| 函数内静态变量 | 当前函数内部 | 函数多次调用之间保持状态 |
| 局部变量 | 当前函数或代码块 | 出了花括号就不可见 |
| 形参变量 | 函数内部 | 行为与局部变量一致 |
